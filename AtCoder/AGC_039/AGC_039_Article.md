# 感想

AGC038と同様に一完に留まりました。  
Bがグラフの問題で全くわからず、Cは法則性を掴めたものの高速な実装を思いつきませんでした。  
また、BとCは解答を見てもよくわからなかったので、Aのみの復習をしていきます。

# [A問題](https://atcoder.jp/contests/agc039/tasks/agc039_a)

例を見て実験を繰り返したところ、繰り返した文字列同士の接合部と接合部でないところにそれぞれ注目すれば良いことに気づきました。  
つまり、n文字連続している場合は、[$\frac{n}{2}$]文字だけ変更することでどの隣合う二文字も異なる文字とすることができます。  
また、文字列が同じ文字のみでできている場合は全ての部分が接合部となってしまうので、数え上げの仕方を変える必要があります。



そして、groupby関数は配列について前から順に要素をまとめていく関数であり、[競プロの応用事項確認\~ランレングス圧縮\~](https://qiita.com/DaikiSuyama/items/07e237b7372e7c7b3432)のように利用することができます。

```Python:answeA.py
from itertools import groupby

s1=input()
k=int(input())

s2=[[h, len(list(g))] for h, g in groupby(s1)] #…(*)

c=0
if len(s2)!=1:
    #接合していない部分の数え上げ
    for i in range(len(s2)):
        #i==0またはlen(s2)-1は接合部なので一旦数えない
        if i!=0 and i!=len(s2)-1:
            c+=(s2[i][1]//2)*k
    #接合部が同じ文字でできているかどうか数え上げの仕方が変わる
    if s2[0][0]==s2[-1][0]:
        c+=((s2[0][1]+s2[-1][1])//2)*(k-1)
        c+=(s2[0][1]//2+s2[-1][1]//2)
    else:
        c+=(s2[0][1]//2+s2[-1][1]//2)*k

else:
    #len(s2)=1の場合は全て同じ文字の文字列になる
    c+=(s2[0][1]*k)//2

print(c)
```
