# 感想

4問目に1時間以上かけたにもかかわらず、考察の丁寧さが足りずに解くことができませんでした。  
大学受験の際と同様、メンタルを安定させることができませんでした。この気が最近は見られるので、治せるように努力したいです。

# [A問題](https://atcoder.jp/contests/keyence2020/tasks/keyence2020_a)

$h,w$の大きい方を選択し続けることが可能なので、そのようにした際の答えを求めます。

```python:answerA.py
import math
h=int(input())
w=int(input())
n=int(input())
k=max(h,w)
print(math.ceil(n/k))
```

# [B問題](https://atcoder.jp/contests/keyence2020/tasks/keyence2020_b)

共通部分があり得る区間の中から共通部分がないように最多の個数の区間を選ぶ場合、区間スケジューリングを使います。区間スケジューリングは、区間の終了時間で昇順ソートして終了時間以降が開始時間となる区間を前から順に選ぶアルゴリズムになります。

区間スケジューリングで最多の個数の区間を選べるかは数学的帰納法により証明できます。最適な区間の選び方が存在したと仮定すると、この最適な選び方は他のどの選び方と比較しても同じ個数を選んだ時に終了時間が遅くない(✳︎)ので、これを簡略化して示します。まず、n=1の時は終了時間が最も早いものを選部ので成り立ちます。n=kで成り立つ時、n=k+1ではn=kで選んだ区間の終了時刻以降に開始する区間の中からその中で終了時間が最も早いものを選ぶので、n=k+1でも同様に成り立ちます。よって、区間スケジューリングにしたがうことで(✳︎)は成り立ちます。

以上の区間スケジューリングを実装して、以下になります。x-lが開始時刻、x+lが終了時刻と考えることで簡単に解くことができます。

```python:answerB.py
n=int(input())
sec=[list(map(int,input().split())) for i in range(n)]
for i in range(n):
    sec[i][0]+=l
    sec[i][1]-=l
sec.sort()

ans=0
#-inf
t=-10000000000
for i in range(n):
    #=をつけるのを忘れずに
    if t<=sec[i][1]:#スタートがロボットアームのある最大の座標以上でなければならない
        ans+=1#以上なら+1
        t=sec[i][0]#ロボットアームのある最大の座標を更新
print(ans)
```

# [C問題](https://atcoder.jp/contests/keyence2020/tasks/keyence2020_c)

$1 \leqq l \leqq  r \leqq n$とありますが、$l=r$の場合を考えるとすぐに考察が終了します。

$s$が$k$個で$s+1$が$n-k$個のパターンを考えれば$l=r$で$k$個を選ぶことができます。  
ただ、$s=10^9$の時はs+1が制約からはみ出してしまうので、$s+1$ではなく1にすれば良いです(1の和は$s$にならないので)。

```python:answerC.py
n,k,s=map(int,input().split())
if s<10**9:
    x=[s]*k
    y=[s+1]*(n-k)
else:
    x=[s]*k
    y=[1]*(n-k)
z=" ".join(map(str,x))+" "+" ".join(map(str,y))
print(z)
```
